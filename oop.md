# ооп

___

[к темам вопросов](README.md)

- [Что такое ооп?](#что-такое-ооп)
- [Назовите основные принципы ооп.](#назовите-основные-принципы-ооп)
- [Что такое "инкапсуляция" ?](#что-такое-инкапсуляция)
- [Что такое "наследование" ?](#что-такое-наследование)
- [Что такое "полиморфизм" ?](#что-такое-полиморфизм)
- [Что такое "Что такое "абстракция" ?](#что-такое-абстракция)
- [Что такое "Что такое "абстракция" ?](#что-такое-абстракция)
- [Расскажите про основвные понятия ооп:"класс", "объект", "интерфейс".](#расскажите-про-основвные-понятия-оопкласс-объект-интерфейс)
- [В чем заключаются преимущества и недостатки объектно-ориентированного подхода в программировании?](#в-чем-заключаются-преимущества-и-недостатки-объектно-ориентированного-подхода-в-программировании)
- [Что подразумевают в плане принципов ооп выражения «является» и «имеет»?](#что-подразумевают-в-плане-принципов-ооп-выражения-является-и-имеет)
- [В чем разница между композицией и агрегацией?](#в-чем-разница-между-композицией-и-агрегацией)
- [Что такое статическое и динамическое связывание?](#что-такое-статическое-и-динамическое-связывание)

## Что такое ооп?

___

Объектно-ориентированное программирование (ооп) — методология программирования, основанная на представлении программы в
виде совокупности объектов, каждый из которых является экземпляром определенного класса,
а классы образуют иерархию наследования. Логика программы реализуется через обмен сообщениями между объектами
классов.

Класс — это тип данных, созданный пользователем. Он содержит разные свойства и методы, как, например, тип String или Int.

Объект — это экземпляр класса, или его копия, которая находится в памяти компьютера. Например, когда вы создаёте
переменную типа String и присваиваете ей значение «Строка», то в памяти создаётся экземпляр класса String.

Программа считается объектно-ориентированной, только если выполнены три требования:
* объектно-ориентированное программирование использует в качестве основных логических
   конструктивных элементов объекты, а не алгоритмы;
* каждый объект является экземпляром определенного класса
* классы образуют иерархии.

[к началу](#ооп)

[к оглавлению](README.md)

## Назовите основные принципы ооп.

___

- Инкапсуляция - сокрытие реализации.
- Наследование - создание новой сущности на базе уже существующей.
- Полиморфизм - возможность иметь разные формы для одной и той же сущности.
- Абстракция - набор общих характеристик.
- Посылка сообщений - форма связи, взаимодействия между сущностями.
- Переиспользование - все что перечислено выше работает на повторное использование кода.

[к началу](#ооп)

[к оглавлению](README.md)

## Что такое "инкапсуляция"?

___

Инкапсуляция – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть
детали реализации от пользователя, открыв только то, что необходимо при последующем использовании.

Цель инкапсуляции — уйти от зависимости внешнего интерфейса класса (то, что могут использовать другие классы) от
реализации. Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.

Пример:
````Java
public class SomePhone {

    private int year;
    private String company;
    public SomePhone(int year, String company) {
        this.year = year;
        this.company = company;
    }
    private void openConnection(){
        //findCommutator
        //openNewConnection...
    }
    public void call() {
        openConnection();
        System.out.println("Вызываю номер");
    }

    public void ring() {
        System.out.println("Дзынь-дзынь");
    }

}
````

Модификатор private делает доступными поля и методы класса только внутри данного класса. Это означает, что получить
доступ к private полям извне невозможно, как и нет возможности вызвать private методы.

Сокрытие доступа к методу openConnection, оставляет нам также возможность к свободному изменению внутренней реализации
этого метода, так как этот метод гарантированно не используется другими объектами и не нарушит их работу.

Для работы с нашим объектом мы оставляем открытыми методы call и ring с помощью модификатора public. Предоставление
открытых методов для работы с объектом также является частью механизма инкапсуляции, так как если полностью закрыть
доступ к объекту – он станет бесполезным.

[к началу](#ооп)

[к оглавлению](README.md)

## Что такое "наследование"?

___

Наследование (inheritance) — механизм, который позволяет описать новый класс на основе существующего (родительского).
При этом свойства и функциональность родительского класса заимствуются новым классом.

Пример:
````java
public class Car {

   private String model;
   private int maxSpeed;
   private int yearOfManufacture;

   public Car(String model, int maxSpeed, int yearOfManufacture) {
       this.model = model;
       this.maxSpeed = maxSpeed;
       this.yearOfManufacture = yearOfManufacture;
   }


public void gas() {
       //...газ
   }

public void brake() {
       //...тормоз
   }
}


public class Truck extends Car {

   public Truck(String model, int maxSpeed, int yearOfManufacture) {
       super(model, maxSpeed, yearOfManufacture);
   }
}



public class Sedan extends Car {
   public Sedan(String model, int maxSpeed, int yearOfManufacture) {
       super(model, maxSpeed, yearOfManufacture);
   }
}
````

Какие выгоды это нам дает? Прежде всего — сокращение объема кода.

Конечно, можем обойтись и без родительского класса. Но поскольку каждая машина должна уметь газовать и тормозить,
нам придется создавать методы gas() и brake() в классе Truck, в классе Sedan, в классе F1Car, в классе Sportcar и
во всех остальных классах машин.

Представь, сколько лишнего кода мы при этом напишем. Не забывай и о полях model, maxSpeed и yearOfManufacture: если
откажемся от родительского класса, будем создавать их в каждом из классов-машин!


[к началу](#ооп)

[к оглавлению](README.md)

## Что такое "полиморфизм"?

___

Полиморфизм – это способность программы идентично использовать объекты с одинаковым интерфейсом без информации о
конкретном типе этого объекта.

___Типы полиморфизма___ - Два варианта реализации полиморфизма в Java:
1. Overloading – перегрузка метода (сюда же перегрузка конструктора).
   При перегрузке метода мы в одном классе создаем нескольких методов с одинаковым названием, но разным функционалом, например:
````java
class Forms{
  public void shapeArea() {
    System.out.println("Площади фигур:");
  }
public void shapeArea(int r) {
    System.out.println("Sкруга = "+3.14*r*r);
  }
public void shapeArea(double b, double h) {
    System.out.println("Sтреугольника ="+0.5*b*h);
  }
public void shapeArea(int l, int b) {
    System.out.println("Sпрямоугольника ="+l*b);
  }
}
````
2. Overriding – переопределение метода. При переопределении название метода дочернего класса мы ставим такое же, как и уже объявленного метода родительского класса, например:
````java
class Vehicles{  
    // определение метода
    void drive(){
System.out.println("Управлять транспортным средством");}  
}  
//создаем дочерний класс
class Cars extends Vehicles {
    //определяем одноименный метод
   @Override
    void drive() {
        System.out.println("Управлять автомобилем");
    }
}
````
___Статический и динамический полиморфизм___.

При статическом варианте развития событий метод можно вызывать при компиляции кода, происходит это при помощи
рассмотренной нами ранее концепции — перегрузки методов. Говоря проще, у них будет одинаковое название, но разная
функциональная начинка (тип возвращаемых данных, свойств и т. д.). В таком случае Java позволяет пользователю свободно
определять функциям идентичные названия, если они будут отличны по типу и параметрам.

При динамическом полиморфизме вызвать переопределеный метод можно при выполнении программы. Скопировать метод
родительского класса и обозначить его в дочернем можно с помощью ссылочной переменной родительского класса,
при этом вызванный метод будет определяться по объекту, на который она ссылается. Такую операцию еще называют Upcasting

[к началу](#ооп)

[к оглавлению](README.md)

## Что такое "абстракция"?

___

Абстрагирование – это способ выделить набор общих характеристик объекта, исключая из рассмотрения частные и
незначимые. Соответственно, абстракция – это набор всех таких характеристик.

Представьте, что водитель едет в автомобиле по оживлённому участку движения. Понятно, что в этот момент он не будет
задумываться о химическом составе краски автомобиля, особенностях взаимодействия шестерёнок в коробке передач или
влияния формы кузова на скорость (разве что, автомобиль стоит в глухой пробке и водителю абсолютно нечем заняться).
Однако, руль, педали, указатель поворота он будет использовать регулярно.

Пример абстракции:
````java
// Abstract class
abstract class Animal {
    // Abstract method (does not have a body)
    public abstract void animalSound();

    // Regular method
    public void sleep() {
        System.out.println("Zzz");
    }
}

// Subclass (inherit from Animal)
class Pig extends Animal {
    public void animalSound() {
        // The body of animalSound() is provided here
        System.out.println("The pig says: wee wee");
    }
}
````

[к началу](#ооп)

[к оглавлению](README.md)

## Расскажите про основвные понятия ооп:"класс", "объект", "интерфейс".

___

Класс – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила
для взаимодействия с данной сущностью (контракт).

С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов, членов класса) и функций
для работы с ними (методов).

С точки зрения структуры программы, класс является сложным типом данных.

Объект (экземпляр) – это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью
определяемое классом. Каждый объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на
основе правил, заданных в классе.

Интерфейс – это набор методов класса, доступных для использования. Интерфейсом класса будет являться набор всех его
публичных методов в совокупности с набором публичных атрибутов. По сути, интерфейс специфицирует класс, чётко
определяя все возможные действия над ним.

[к началу](#ооп)

[к оглавлению](README.md)

## В чем заключаются преимущества и недостатки объектно-ориентированного подхода в программировании?

___

Преимущества:
* Объектная модель вполне естественна, поскольку в первую очередь ориентирована на человеческое
восприятие мира, а не на компьютерную реализацию.


* Классы позволяют проводить конструирование из полезных компонентов, обладающих простыми инструментами, что позволяет
абстрагироваться от деталей реализации.


* Данные и операции над ними образуют определенную сущность, и они не разносятся по всей программе, как нередко бывает
в случае процедурного программирования, а описываются вместе. Локализация кода и данных улучшает наглядность и удобство
сопровождения программного обеспечения.


* Инкапсуляция позволяет привнести свойство модульности, что облегчает распараллеливание выполнения задачи между
несколькими исполнителями и обновление версий отдельных компонентов.


* Возможность создавать расширяемые системы.


* Использование полиморфизма оказывается полезным при:
  * Обработке разнородных структур данных. Программы могут работать, не различая вида объектов, что существенно упрощает код. Новые виды могут быть добавлены в любой момент.
  * Изменении поведения во время исполнения. На этапе исполнения один объект может быть заменен другим, что позволяет легко, без изменения кода, адаптировать алгоритм в зависимости от того, какой используется объект.
  * Реализации работы с наследниками. Алгоритмы можно обобщить настолько, что они уже смогут работать более чем с одним видом объектов.
  * Возможности описать независимые от приложения части предметной области в виде набора универсальных классов, или фреймворка, который в дальнейшем будет расширен за счет добавления частей, специфичных для конкретного приложения.


* Повторное использование кода:
  *  Сокращается время на разработку, которое может быть отдано другим задачам.
  *  Компоненты многоразового использования обычно содержат гораздо меньше ошибок, чем вновь разработанные, ведь они уже не раз подвергались проверке.
  * Когда некий компонент используется сразу несколькими клиентами, улучшения, вносимые в его код, одновременно оказывают положительное влияние и на множество работающих с ним программ.
  * Если программа опирается на стандартные компоненты, ее структура и пользовательский интерфейс становятся более унифицированными, что облегчает ее понимание и упрощает использование.

Недостатки:
* В сложных иерархиях классов поля и методы обычно наследуются с разных уровней. И не всегда легко определить,
какие поля и методы фактически относятся к данному классу.

* Код для обработки сообщения иногда «размазан» по многим методам (иначе говоря, обработка сообщения требует не
одного, а многих методов, которые могут быть описаны в разных классах).

* Документирование классов - задача более трудная, чем это было в случае процедур и модулей. Поскольку любой метод
может быть переопределен, в документации должно говориться не только о том, что делает данный метод, но и о том,
в каком контексте он вызывается.

* Неэффективность и неэкономное распределения памяти на этапе выполнения (по причине издержек на динамическое
связывание и проверки типов на этапе выполнения).

* Излишняя универсальность. Часто содержится больше методов, чем это реально необходимо текущей программе.
А поскольку лишние методы не могут быть удалены, они становятся мертвым грузом.

[к началу](#ооп)

[к оглавлению](README.md)

## Что подразумевают в плане принципов ооп выражения «является» и «имеет»?

___

«является» подразумевает наследование. «имеет» подразумевает ассоциацию (агрегацию или композицию).

[к началу](#ооп)

[к оглавлению](README.md)

## В чем разница между композицией и агрегацией?

___

Ассоциация обозначает связь между объектами. Композиция и агрегация — частные случаи ассоциации «часть-целое».


Агрегация предполагает, что объекты связаны взаимоотношением «part-of» (часть). Композиция более строгий вариант
агрегации. Дополнительно к требованию «part-of» накладывается условие, что экземпляр «части» может входить только в
одно целое (или никуда не входить), в то время как в случае агрегации экземпляр «части» может входить в несколько целых.


Например, книга состоит из страниц, и мы не можем вырвать страницу из книги и вложить в другую книгу. Страницы четко
привязаны к конкретной книге, поэтому это композиция. В тоже время мы можем взять и перенести книгу из одной
библиотеки в другую - это уже агрегация.

[к началу](#ооп)

[к оглавлению](README.md)

## Что такое статическое и динамическое связывание?

___

Присоединение вызова метода к телу метода называется связыванием. Если связывание проводится компилятором
(компоновщиком) перед запуском программы, то оно называется статическим или ранним связыванием (early binding).

В свою очередь, позднее связывание (late binding) это связывание, проводимое непосредственно во время выполнения
программы, в зависимости от типа объекта. Позднее связывание также называют динамическим (dynamic) или связыванием на
стадии выполнения (runtime binding). В языках, реализующих позднее связывание, должен существовать механизм
определения фактического типа объекта во время работы программы, для вызова подходящего метода. Иначе говоря,
компилятор не знает тип объекта, но механизм вызова методов определяет его и вызывает соответствующее тело метода.
Механизм позднего связывания зависит от конкретного языка, но нетрудно предположить, что для его реализации в объекты
должна включаться какая-то дополнительная информация.

Для всех методов Java используется механизм позднего (динамического) связывания, если только метод не был объявлен
как final, static или private (приватные методы являются final по умолчанию).

[к началу](#ооп)

[к оглавлению](README.md)






